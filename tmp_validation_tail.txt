  try {
    const url = new URL(request.url)
    const params = Object.fromEntries(url.searchParams.entries())

    const result = schema.parse(params)
    return result
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw transformZodError(error, requestId)
    }
    throw new ValidationError('쿼리 파라미터가 올바르지 않습니다', { originalError: error }, requestId)
  }
}

// 경로 파라미터 검증
export function validatePathParams<T>(
  params: Record<string, string>,
  schema: z.ZodSchema<T>,
  requestId?: string
): T {
  try {
    const result = schema.parse(params)
    return result
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw transformZodError(error, requestId)
    }
    throw new ValidationError('경로 파라미터가 올바르지 않습니다', { originalError: error }, requestId)
  }
}

// 헤더 검증
export function validateHeaders<T>(
  request: NextRequest,
  schema: z.ZodSchema<T>,
  requestId?: string
): T {
  try {
    const headers: Record<string, string> = {}
    request.headers.forEach((value, key) => {
      headers[key.toLowerCase()] = value
    })

    const result = schema.parse(headers)
    return result
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw transformZodError(error, requestId)
    }
    throw new ValidationError('요청 헤더가 올바르지 않습니다', { originalError: error }, requestId)
  }
}

// 통합 검증 함수
export async function validateRequest<TBody, TQuery, TParams>(
  request: NextRequest,
  schemas: {
    body?: z.ZodSchema<TBody>
    query?: z.ZodSchema<TQuery>
    params?: z.ZodSchema<TParams>
    headers?: z.ZodSchema<any>
  },
  params?: Record<string, string>,
  requestId?: string
): Promise<{
  body?: TBody
  query?: TQuery
  params?: TParams
  headers?: any
}> {
  const result: any = {}

  // 본문 검증
  if (schemas.body && ['POST', 'PUT', 'PATCH'].includes(request.method)) {
    result.body = await validateRequestBody(request, schemas.body, requestId)
  }

  // 쿼리 파라미터 검증
  if (schemas.query) {
    result.query = validateQueryParams(request, schemas.query, requestId)
  }

  // 경로 파라미터 검증
  if (schemas.params && params) {
    result.params = validatePathParams(params, schemas.params, requestId)
  }

  // 헤더 검증
  if (schemas.headers) {
    result.headers = validateHeaders(request, schemas.headers, requestId)
  }

  return result
}

// 파일 업로드 검증
export function validateFileUpload(
  file: File,
  options: {
    maxSize?: number
    allowedTypes?: string[]
    allowedExtensions?: string[]
  } = {},
  requestId?: string
): void {
  const {
    maxSize = 10 * 1024 * 1024, // 10MB
    allowedTypes = [],
    allowedExtensions = []
  } = options

  // 파일 크기 검증
  if (file.size > maxSize) {
    throw new ValidationError(
      `파일 크기는 ${Math.round(maxSize / 1024 / 1024)}MB 이하여야 합니다`,
      { fileSize: file.size, maxSize },
      requestId
    )
  }

  // 파일 타입 검증
  if (allowedTypes.length > 0 && !allowedTypes.includes(file.type)) {
    throw new ValidationError(
      '지원되지 않는 파일 형식입니다',
      { fileType: file.type, allowedTypes },
      requestId
    )
  }

  // 파일 확장자 검증
  if (allowedExtensions.length > 0) {
    const extension = file.name.split('.').pop()?.toLowerCase()
    if (!extension || !allowedExtensions.includes(extension)) {
      throw new ValidationError(
        '지원되지 않는 파일 확장자입니다',
        { extension, allowedExtensions },
        requestId
      )
    }
  }
}

// 배치 검증 (여러 항목 검증)
export function validateBatch<T>(
  items: unknown[],
  schema: z.ZodSchema<T>,
  maxItems: number = 100,
  requestId?: string
): T[] {
  if (!Array.isArray(items)) {
    throw new ValidationError('배열 형태의 데이터가 필요합니다', undefined, requestId)
  }

  if (items.length === 0) {
    throw new ValidationError('최소 1개 이상의 항목이 필요합니다', undefined, requestId)
  }

  if (items.length > maxItems) {
    throw new ValidationError(
      `한 번에 최대 ${maxItems}개까지만 처리할 수 있습니다`,
      { itemCount: items.length, maxItems },
      requestId
    )
  }

  try {
    return items.map((item, index) => {
      try {
        return schema.parse(item)
      } catch (error) {
        if (error instanceof z.ZodError) {
          const validationError = transformZodError(error, requestId)
          validationError.details.index = index
          throw validationError
        }
        throw error
      }
    })
  } catch (error) {
    if (error instanceof ValidationError) {
      throw error
    }
    throw new ValidationError('배치 데이터 검증에 실패했습니다', { originalError: error }, requestId)
  }
}

// 조건부 검증 (특정 조건에서만 검증)
export function validateConditional<T>(
  data: unknown,
  schema: z.ZodSchema<T>,
  condition: boolean,
  requestId?: string
): T | undefined {
  if (!condition) {
    return undefined
  }

  try {
    return schema.parse(data)
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw transformZodError(error, requestId)
    }
    throw new ValidationError('조건부 검증에 실패했습니다', { originalError: error }, requestId)
  }
}

// 비즈니스 규칙 검증 헬퍼
export const BusinessValidators = {
  // 디자인 옵션 조합 검증
  validateDesignCombination: (options: any, requestId?: string): void => {
    const { material, finish, width_cm, height_cm } = options

    // 유리 재질의 경우 높이 제한
    if (material === 'glass' && height_cm > 200) {
      throw new ValidationError(
        '유리 재질의 경우 높이는 200cm를 초과할 수 없습니다',
        { material, height_cm },
        requestId
      )
    }

    // 금속 재질의 경우 특정 마감재만 가능
    if (material === 'metal' && finish && !['matte', 'glossy'].includes(finish)) {
      throw new ValidationError(
        '금속 재질의 경우 무광(matte) 또는 광택(glossy) 마감재만 선택할 수 있습니다',
        { material, finish },
        requestId
      )
    }

    // 너비가 300cm 이상인 경우 특별 제작 안내
    if (width_cm >= 300) {
      // 이것은 경고성 메시지이므로 로그로 기록하고 통과
      console.warn(`Large width detected: ${width_cm}cm - Special manufacturing required`)
    }
  },

  // 가격 계산 요청 검증
  validatePricingRequest: (request: any, requestId?: string): void => {
    const { quantity, options, discountCode } = request

    // 대량 주문시 확인
    if (quantity > 50) {
      console.info(`Bulk order detected: ${quantity} items`)
    }

    // 할인 코드 형식 검증 (간단한 예시)
    if (discountCode && !/^[A-Z0-9]{6,10}$/.test(discountCode)) {
      throw new ValidationError(
        '올바른 할인 코드 형식이 아닙니다 (6-10자리 대문자/숫자)',
        { discountCode },
        requestId
      )
    }

    // 디자인 옵션 조합 검증
    BusinessValidators.validateDesignCombination(options, requestId)
  }
}

# Story 1.2D: React 무한 루프 긴급 수정 - 컨피규레이터 페이지

## Status

Draft

## Story

**As a** 개발자,
**I want** /configurator 페이지의 React 무한 루프를 완전히 해결,
**So that** 사용자가 3D 컨피규레이터를 정상적으로 사용할 수 있습니다.

## Story Context

이 스토리는 Story 1.2C (BLOCKED)에서 분리된 긴급 수정 스토리입니다. Story 1.2C에서 여러 차례 시도했으나 해결하지 못한 React 무한 루프 문제를 집중적으로 해결합니다.

**분리 배경:**
- Story 1.2C가 너무 많은 이슈를 포함 (Epic 1, 2, 3의 이슈 혼재)
- Dev Agent의 부분적 수정만으로는 해결 불가능
- 컴포넌트 간 복잡한 상호 의존성 문제

**근본 원인 (QA 분석):**
1. ConfiguratorUI ↔ ControlPanel ↔ ThreeCanvas 간 순환 참조
2. useEffect 의존성 배열 관리 문제
3. props drilling으로 인한 불필요한 리렌더링 전파

## Acceptance Criteria

1. `/configurator` 페이지 접근 시 "Maximum update depth exceeded" 에러가 발생하지 않아야 함
2. 브라우저 크래시 없이 페이지가 정상적으로 로드되어야 함
3. 3D 씬이 정상적으로 표시되어야 함
4. Slider 조작 시 무한 루프가 발생하지 않아야 함
5. 재료 선택 시 무한 루프가 발생하지 않아야 함
6. 브라우저 콘솔에 React 무한 루프 관련 에러가 없어야 함
7. 성능: 모바일에서 최소 30 FPS 유지 (NFR1 준수)

## Tasks / Subtasks

- [ ] **Task 1: 현재 무한 루프 원인 정밀 분석** (AC: 1, 6)
  - [ ] React DevTools Profiler로 렌더링 체인 분석
  - [ ] useEffect 의존성 배열 전체 점검
  - [ ] props 전달 구조 맵핑
  - [ ] 콘솔 에러 스택 트레이스 분석

- [ ] **Task 2: ConfiguratorUI 컴포넌트 리팩토링** (AC: 1, 2, 3)
  - [ ] useEffect 의존성 최적화
  - [ ] useRef 패턴으로 불필요한 리렌더링 방지
  - [ ] handleSettingsChange useCallback 최적화
  - [ ] BFF API 호출 로직 안정화

- [ ] **Task 3: ControlPanel 컴포넌트 리팩토링** (AC: 4, 5)
  - [ ] Controlled vs Uncontrolled 컴포넌트 패턴 결정
  - [ ] localDimensions 상태 관리 개선
  - [ ] debouncing 로직 최적화
  - [ ] stale closure 문제 해결

- [ ] **Task 4: ThreeCanvas 컴포넌트 최적화** (AC: 3, 7)
  - [ ] useEffect 의존성 배열 최적화
  - [ ] Three.js 씬 초기화 로직 개선
  - [ ] 성능 모니터링 콜백 최적화
  - [ ] 메모리 누수 방지

- [ ] **Task 5: 컴포넌트 간 데이터 흐름 재설계** (AC: 1, 4, 5)
  - [ ] props drilling 제거 검토
  - [ ] 상태 관리 패턴 개선 (Context API 또는 상태 끌어올리기)
  - [ ] 이벤트 핸들러 최적화
  - [ ] 불필요한 prop 전달 제거

- [ ] **Task 6: 통합 테스트 및 검증** (AC: 1-7)
  - [ ] 브라우저 수동 테스트 (Chrome, Safari, Firefox)
  - [ ] 모바일 테스트 (iOS, Android)
  - [ ] React DevTools로 렌더링 최적화 확인
  - [ ] 성능 메트릭 측정 (FPS, 메모리 사용량)

- [ ] **Task 7: 회귀 방지 테스트 작성** (AC: 6)
  - [ ] 무한 루프 감지 E2E 테스트 작성
  - [ ] 컴포넌트 단위 테스트 추가
  - [ ] CI/CD 파이프라인에 테스트 통합

## Dev Notes

### 기술 스택 정보
[Source: architecture/tech-stack-안정-버전-확정.md]
- **Frontend Framework**: Next.js 14.x
- **Language**: TypeScript 5.3.x (strict mode)
- **3D Rendering**: Three.js r169 (고정 버전)
- **UI/Styling**: Tailwind CSS 3.x
- **Runtime**: Node.js v20.x (LTS)

### 아키텍처 정보
[Source: architecture/component-analysis-선택-근거-및-위험-분석.md]
- **Architecture Style**: Serverless + Monorepo
- **Core Component**: BFF (API Gateway Service) 패턴
- **Risk**: Cold Start 지연 발생 시 UX 저하
- **Mitigation**: Warm-up 전략 및 Next.js Serverless Functions 최적화

### 현재 파일 구조
- `/src/app/configurator/page.tsx` - 메인 페이지 (dynamic import, Error Boundary 적용)
- `/src/app/configurator/components/ConfiguratorUI.tsx` - 메인 UI 컴포넌트
- `/src/app/configurator/components/ControlPanel.tsx` - 컨트롤 패널
- `/src/components/three/ThreeCanvas.tsx` - 3D 렌더링 컴포넌트
- `/src/components/error-boundary/ConfiguratorErrorBoundary.tsx` - 에러 경계

### 이전 스토리(1.2C) 교훈
[Source: Story 1.2C QA Results]

**실패한 수정 시도들:**
1. useRef + debouncing 패턴 → 불완전한 구현으로 실패
2. defaultValue로 Slider 변경 → UI 불일치 문제 발생
3. useEffect 의존성 배열 수정 → 부분적 수정으로 해결 안 됨

**QA가 제안한 해결 방법들:**

**Option A (권장): Controlled + useRef로 리렌더 방지**
```typescript
const [localDimensions, setLocalDimensions] = useState(settings.dimensions)

useEffect(() => {
  setLocalDimensions(settings.dimensions)
}, [settings.dimensions])

const handleDimensionChange = (dimension, value) => {
  const newDims = { ...localDimensions, [dimension]: value }
  setLocalDimensions(newDims)  // 즉시 UI 업데이트

  // Debounce는 onSettingsChange만
  if (debounceTimerRef.current) clearTimeout(debounceTimerRef.current)
  debounceTimerRef.current = setTimeout(() => {
    onSettingsChange({ ...settings, dimensions: newDims })
  }, 300)
}
```

**Option B: onValueCommit 사용**
```typescript
<Slider
  value={[mToCm(settings.dimensions.width)]}
  onValueCommit={(value) => {  // 드래그 완료 시만 호출
    handleDimensionChange('width', cmToM(value[0]))
  }}
/>
```

**handleSettingsChange useCallback 최적화:**
```typescript
const availableMaterialsRef = useRef(availableMaterials)
const calculatePriceRef = useRef(calculatePrice)

useEffect(() => {
  availableMaterialsRef.current = availableMaterials
  calculatePriceRef.current = calculatePrice
}, [availableMaterials, calculatePrice])

const handleSettingsChange = useCallback((newSettings) => {
  setSettings(newSettings)

  const currentMaterial = availableMaterialsRef.current.find(...)
  if (currentMaterial) {
    calculatePriceRef.current({...})
  }
}, [])  // 빈 의존성 배열!
```

### Testing Standards

[Source: architecture/testing-strategy.md 추정]
- **Test Location**: `__tests__/` 디렉토리
- **Unit Tests**: Jest + React Testing Library
- **E2E Tests**: Playwright
- **Performance Tests**: 3D 렌더링 FPS, API 응답 시간

### 중요 제약사항

1. **성능 요구사항 (NFR1)**: 모바일에서 30 FPS 이상 유지
2. **브라우저 호환성**: Chrome, Safari, Firefox 최신 2개 버전
3. **TypeScript strict mode** 준수
4. **Three.js r169** 버전 고정 (변경 금지)

## Change Log

| Date | Version | Description | Author |
|:-----|:--------|:------------|:-------|
| 2025-10-02 | 1.0 | Initial story creation from 1.2C split | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by Dev Agent_

### Debug Log References
_To be filled by Dev Agent_

### Completion Notes List
_To be filled by Dev Agent_

### File List
_To be filled by Dev Agent_

## QA Results
_To be filled by QA Agent_